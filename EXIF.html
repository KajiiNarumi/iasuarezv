 
<!doctype html>

<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lector EXIF â€” 100% local en tu navegador</title>
  <style>
    :root { --bg:#0b0c10; --card:#111318; --muted:#9aa3b2; --text:#e6e9ef; --accent:#7c9fff; --ok:#24d39a; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text); }
    header { padding:28px 20px 10px; text-align:center; }
    h1 { margin:0 0 8px; font-size: clamp(20px, 4vw, 28px); }
    p.sub { margin:0; color:var(--muted); }
    main { max-width: 980px; margin: 20px auto 60px; padding: 0 16px; }
    .card { background: var(--card); border: 1px solid #1b1e25; border-radius: 16px; padding: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .uploader { display:flex; gap:16px; align-items:center; flex-wrap: wrap; }
    .uploader input[type=file] { display:none; }
    .btn { display:inline-flex; align-items:center; gap:10px; padding:12px 16px; border-radius: 12px; border:1px solid #262a33; background:#141720; color:var(--text); cursor:pointer; font-weight:600; }
    .btn:hover { border-color:#2f3542; }
    .btn.secondary { background:transparent; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .preview { margin-top:16px; display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .thumb { width: 260px; aspect-ratio: 4/3; border-radius: 12px; overflow:hidden; border:1px solid #222733; background:#0e1015; display:grid; place-items:center; }
    .thumb img { max-width:100%; max-height:100%; object-fit:contain; }
    .meta { flex:1 1 380px; min-width:320px; }
    .grid { display:grid; grid-template-columns: 220px 1fr; gap:8px 14px; }
    .key { color:var(--muted); }
    .value { word-break: break-word; }
    details { margin-top: 18px; }
    details pre { white-space: pre-wrap; background:#0e1015; padding:12px; border-radius:10px; border:1px solid #1a1f29; }
    .actions { margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; }
    .pill { font-size:12px; color:#9aa3b2; background:#0e1015; padding:6px 10px; border-radius:999px; border:1px solid #1a1f29; }
    footer { color:var(--muted); text-align:center; margin: 30px 0 60px; font-size: 13px; }
    .hint { color:#b2b9c8; font-size:13px; }
  </style>
</head>
<body>
  <header>
    <h1>Lector EXIF (funciona 100% local)</h1>
    <p class="sub">Sube una foto (idealmente JPEG). Extrae EXIF, GPS y mÃ¡s. Nada sale de tu navegador.</p>
  </header>  <main>
    <section class="card">
      <div class="uploader">
        <label class="btn" for="file">ðŸ“· Elegir imagen</label>
        <input id="file" type="file" accept="image/*" />
        <button id="btnCopy" class="btn secondary" disabled>ðŸ“‹ Copiar JSON</button>
        <button id="btnSave" class="btn secondary" disabled>ðŸ’¾ Descargar JSON</button>
        <span id="fileInfo" class="pill" hidden></span>
      </div><div class="preview">
    <div class="thumb"><img id="img" alt="Vista previa" /></div>
    <div class="meta">
      <div class="grid" id="hero"></div>
      <details>
        <summary>Ver todo el EXIF (completo)</summary>
        <pre id="all"></pre>
      </details>
      <p class="hint">Soporte principal: <b>JPEG</b>. Algunos PNG pueden incluir chunk EXIF pero no es comÃºn. HEIC/WEBP varÃ­a segÃºn el dispositivo.</p>
    </div>
  </div>
</section>

  </main>  <footer>
    Hecho con cariÃ±o. Basado en lectura de APP1/Exif y cabecera TIFF.
  </footer><script>
(function(){
  const fileInput = document.getElementById('file');
  const imgEl = document.getElementById('img');
  const hero = document.getElementById('hero');
  const allEl = document.getElementById('all');
  const btnCopy = document.getElementById('btnCopy');
  const btnSave = document.getElementById('btnSave');
  const fileInfo = document.getElementById('fileInfo');

  fileInput.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    // preview
    imgEl.src = URL.createObjectURL(f);
    fileInfo.hidden = false; fileInfo.textContent = `${f.name} â€” ${(f.size/1024).toFixed(1)} KB`;

    const ab = await f.arrayBuffer();
    const exif = parseEXIF(new DataView(ab));

    // Build nice summary
    const summary = summarize(exif);
    renderKeyVals(hero, summary);

    const full = JSON.stringify(exif, replacer, 2);
    allEl.textContent = full;

    btnCopy.disabled = false; btnSave.disabled = false;
    btnCopy.onclick = async ()=>{ try{ await navigator.clipboard.writeText(full); btnCopy.textContent = 'âœ… Copiado'; setTimeout(()=>btnCopy.textContent='ðŸ“‹ Copiar JSON',1200); }catch(e){ alert('No se pudo copiar: '+e); } };
    btnSave.onclick = ()=>{
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([full], {type:'application/json'}));
      a.download = (f.name.replace(/\.[^.]+$/, '') || 'exif') + '.exif.json';
      a.click();
    };
  });

  function renderKeyVals(container, obj){
    container.innerHTML = '';
    const entries = Object.entries(obj);
    if(entries.length===0){ container.innerHTML = '<span class="hint">No se encontraron campos EXIF visibles.</span>'; return; }
    for(const [k,v] of entries){
      const kEl = document.createElement('div'); kEl.className='key'; kEl.textContent=k;
      const vEl = document.createElement('div'); vEl.className='value'; vEl.textContent = (typeof v === 'object')? JSON.stringify(v): String(v);
      container.appendChild(kEl); container.appendChild(vEl);
    }
  }

  function replacer(key, value){
    if(value && typeof value === 'object' && 'num' in value && 'den' in value && Object.keys(value).length===2){
      return `${value.num}/${value.den}`;
    }
    return value;
  }

  function summarize(exif){
    const gps = exif.GPS || {};
    const core = exif.IFD0 || {};
    const ex = exif.ExifIFD || {};
    const obj = {};
    if(core.Make) obj.Marca = core.Make;
    if(core.Model) obj.Modelo = core.Model;
    if(ex.LensModel) obj['Lente'] = ex.LensModel;
    if(ex.DateTimeOriginal || core.DateTime) obj['Fecha (original)'] = ex.DateTimeOriginal || core.DateTime;
    if(ex.FNumber) obj['Apertura (f)'] = rationalToF(ex.FNumber);
    if(ex.ExposureTime) obj['ExposiciÃ³n'] = rationalToShutter(ex.ExposureTime);
    if(ex.ISOSpeedRatings) obj.ISO = ex.ISOSpeedRatings;
    if(ex.FocalLength) obj['Focal'] = rationalToFixed(ex.FocalLength,1)+' mm';
    if(core.Orientation) obj.OrientaciÃ³n = core.Orientation;
    const glat = toDecimal(gps.GPSLatitude, gps.GPSLatitudeRef);
    const glon = toDecimal(gps.GPSLongitude, gps.GPSLongitudeRef);
    if(Number.isFinite(glat) && Number.isFinite(glon)) obj['GPS'] = `${glat.toFixed(6)}, ${glon.toFixed(6)}`;
    if(gps.GPSAltitude) obj['Altitud'] = rationalToFixed(gps.GPSAltitude,1) + ' m';
    return obj;
  }

  function rationalToFixed(r, d=2){ if(!r) return null; return (r.num/r.den).toFixed(d); }
  function rationalToF(r){ if(!r) return null; const v = (r.num/r.den); return 'f/' + (v>=10? v.toFixed(0) : v.toFixed(1)); }
  function rationalToShutter(r){ if(!r) return null; const v = r.num/r.den; if(v>=1) return v.toFixed(1)+' s'; const den = Math.round(1/v); return `1/${den} s`; }
  function toDecimal(dms, ref){
    if(!dms || !Array.isArray(dms)) return NaN;
    const [d,m,s] = dms.map(x=> x.num/x.den);
    let val = d + m/60 + s/3600;
    if(ref==='S' || ref==='W') val = -val; return val;
  }

  // EXIF Parser (JPEG APP1 only, TIFF IFDs)
  function parseEXIF(view){
    // Verify JPEG
    if(view.getUint16(0) !== 0xFFD8){ return {}; }
    let offset = 2;
    const len = view.byteLength;
    while(offset < len){
      const marker = view.getUint16(offset); offset += 2;
      if(marker === 0xFFE1){ // APP1
        const size = view.getUint16(offset); // size includes size field
        const start = offset + 2;
        // Expect "Exif\0\0"
        if(view.getUint32(start) === 0x45786966 && view.getUint16(start+4)===0x0000){
          const tiffStart = start + 6;
          return readTIFF(view, tiffStart);
        }
        offset += size;
      } else if(marker >= 0xFFD0 && marker <= 0xFFDA){
        // other marker with size
        if(marker === 0xFFDA){ break; } // SOS -> image data, stop
        const size = view.getUint16(offset); offset += size;
      } else if((marker & 0xFFF0) === 0xFFE0){
        const size = view.getUint16(offset); offset += size; // skip other APPn
      } else {
        break;
      }
    }
    return {};
  }

  function readTIFF(view, tiffOffset){
    const order = view.getUint16(tiffOffset);
    const little = order === 0x4949; // 'II'
    if(!little && order !== 0x4D4D) return {};
    const get16 = (o)=> little? view.getUint16(o,true): view.getUint16(o,false);
    const get32 = (o)=> little? view.getUint32(o,true): view.getUint32(o,false);

    const magic = get16(tiffOffset+2); if(magic !== 0x002A) return {};
    const ifd0Offset = get32(tiffOffset+4) + tiffOffset;

    const ctx = { view, tiffOffset, little, get16, get32 };
    const IFD0 = readIFD(ctx, ifd0Offset);

    let nextIFDOffset = get32(ifd0Offset + 2 + (IFD0.__count||0)*12);
    if(nextIFDOffset) nextIFDOffset += tiffOffset;

    // Pointers
    const ExifIFDPointer = IFD0[0x8769];
    const GPSInfoIFDPointer = IFD0[0x8825];

    const ExifIFD = ExifIFDPointer ? readIFD(ctx, tiffOffset + ExifIFDPointer) : {};
    const GPS = GPSInfoIFDPointer ? readIFD(ctx, tiffOffset + GPSInfoIFDPointer, true) : {};

    // Clean up numeric keys and map names
    const namedIFD0 = mapIFDNames(IFD0, TAGS.IFD0);
    const namedExif = mapIFDNames(ExifIFD, TAGS.ExifIFD);
    const namedGPS = mapIFDNames(GPS, TAGS.GPS);

    return { IFD0: namedIFD0, ExifIFD: namedExif, GPS: namedGPS };
  }

  function readIFD(ctx, ifdOffset, isGPS=false){
    const { view, tiffOffset, get16, get32, little } = ctx;
    const num = get16(ifdOffset);
    const out = { __count: num };
    for(let i=0; i<num; i++){
      const entry = ifdOffset + 2 + i*12;
      const tag = get16(entry);
      const type = get16(entry+2);
      const count = get32(entry+4);
      const valueOffset = entry+8;

      const val = readValue(view, tiffOffset, type, count, valueOffset, little);
      out[tag] = val;
    }
    return out;
  }

  function readValue(view, tiffOffset, type, count, valueOffset, little){
    const get16 = (o)=> little? view.getUint16(o,true): view.getUint16(o,false);
    const get32 = (o)=> little? view.getUint32(o,true): view.getUint32(o,false);
    const get8 = (o)=> view.getUint8(o);

    const TYPE_SIZES = {1:1, 2:1, 3:2, 4:4, 5:8, 7:1, 9:4, 10:8};
    const size = (TYPE_SIZES[type]||1) * count;

    let offset = valueOffset;
    if(size > 4){ offset = get32(valueOffset) + tiffOffset; }

    function readRational(ofs, signed){
      const num = get32(ofs);
      const den = get32(ofs+4);
      return { num: signed? toSigned(num) : num, den: signed? toSigned(den) : den };
    }
    function toSigned(v){ return v>0x7FFFFFFF ? v-0x100000000 : v; }

    switch(type){
      case 1: // BYTE
        if(count===1) return get8(offset);
        return [...Array(count)].map((_,i)=> get8(offset+i));
      case 2: { // ASCII
        let s = '';
        for(let i=0;i<count-1;i++){ s += String.fromCharCode(get8(offset+i)); }
        return s; }
      case 3: // SHORT
        if(count===1) return get16(offset);
        return [...Array(count)].map((_,i)=> get16(offset + i*2));
      case 4: // LONG
        if(count===1) return get32(offset);
        return [...Array(count)].map((_,i)=> get32(offset + i*4));
      case 5: // RATIONAL
        if(count===1) return readRational(offset,false);
        return [...Array(count)].map((_,i)=> readRational(offset + i*8,false));
      case 7: // UNDEFINED (treat as bytes)
        return [...Array(count)].map((_,i)=> get8(offset+i));
      case 9: // SLONG
        if(count===1) return toSigned(get32(offset));
        return [...Array(count)].map((_,i)=> toSigned(get32(offset + i*4)));
      case 10: // SRATIONAL
        if(count===1) return readRational(offset,true);
        return [...Array(count)].map((_,i)=> readRational(offset + i*8,true));
      default:
        return null;
    }
  }

  const TAGS = {
    IFD0: {
      0x010F: 'Make',
      0x0110: 'Model',
      0x0112: 'Orientation',
      0x0131: 'Software',
      0x0132: 'DateTime',
      0x8298: 'Copyright',
      0x8769: 'ExifIFDPointer',
      0x8825: 'GPSInfoIFDPointer',
    },
    ExifIFD: {
      0x829A: 'ExposureTime',
      0x829D: 'FNumber',
      0x8827: 'ISOSpeedRatings',
      0x9003: 'DateTimeOriginal',
      0x9004: 'DateTimeDigitized',
      0x920A: 'FocalLength',
      0xA002: 'PixelXDimension',
      0xA003: 'PixelYDimension',
      0xA405: 'FocalLengthIn35mmFilm',
      0xA432: 'LensSpecification',
      0xA433: 'LensMake',
      0xA434: 'LensModel',
    },
    GPS: {
      0x0000: 'GPSVersionID',
      0x0001: 'GPSLatitudeRef',
      0x0002: 'GPSLatitude',
      0x0003: 'GPSLongitudeRef',
      0x0004: 'GPSLongitude',
      0x0005: 'GPSAltitudeRef',
      0x0006: 'GPSAltitude',
      0x0012: 'GPSMapDatum',
      0x001D: 'GPSDateStamp'
    }
  };

  function mapIFDNames(ifd, dict){
    const out = {};
    for(const [k,v] of Object.entries(ifd)){
      if(k==='__count') continue;
      const id = Number(k);
      const name = dict[id] || ('0x'+id.toString(16));
      if(name.endsWith('Pointer')) continue; // omit raw pointer offsets
      // prettify some arrays
      if(Array.isArray(v)){
        if(name==='GPSLatitude' || name==='GPSLongitude'){
          out[name] = v; // keep rationals array
        } else {
          out[name] = v;
        }
      } else {
        out[name] = v;
      }
    }
    return out;
  }
})();
</script></body>
</html>